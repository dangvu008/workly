import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';
import {
  UserSettings,
  Shift,
  Note,
  WeatherData,
  ButtonState,
  DailyWorkStatus
} from '../types';
import { storageService } from '../services/storage';
import { workManager } from '../services/workManager';
import { weatherService } from '../services/weather';
import { notificationService } from '../services/notifications';
import { alarmService } from '../services/alarmService';
import { dayOffService } from '../services/dayOffService';
import { format, addDays, startOfWeek } from 'date-fns';

// State interface
interface AppState {
  isLoading: boolean;
  settings: UserSettings | null;
  shifts: Shift[];
  activeShift: Shift | null;
  notes: Note[];
  weatherData: WeatherData | null;
  currentButtonState: ButtonState;
  todayStatus: DailyWorkStatus | null;
  weeklyStatus: Record<string, DailyWorkStatus>;
  timeDisplayInfo: {
    isActiveWindow: boolean;
    shouldShowButton: boolean;
    shouldShowHistory: boolean;
    timeUntilNextReset: number;
    currentPhase: 'before_work' | 'work_time' | 'after_work' | 'inactive';
  } | null;
}

// Action types
type AppAction =
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_SETTINGS'; payload: UserSettings }
  | { type: 'SET_SHIFTS'; payload: Shift[] }
  | { type: 'SET_ACTIVE_SHIFT'; payload: Shift | null }
  | { type: 'SET_NOTES'; payload: Note[] }
  | { type: 'SET_WEATHER_DATA'; payload: WeatherData | null }
  | { type: 'SET_BUTTON_STATE'; payload: ButtonState }
  | { type: 'SET_TODAY_STATUS'; payload: DailyWorkStatus | null }
  | { type: 'SET_WEEKLY_STATUS'; payload: Record<string, DailyWorkStatus> }
  | { type: 'SET_TIME_DISPLAY_INFO'; payload: AppState['timeDisplayInfo'] }
  | { type: 'UPDATE_SETTINGS'; payload: Partial<UserSettings> }
  | { type: 'ADD_SHIFT'; payload: Shift }
  | { type: 'UPDATE_SHIFT'; payload: { id: string; updates: Partial<Shift> } }
  | { type: 'DELETE_SHIFT'; payload: string }
  | { type: 'ADD_NOTE'; payload: Note }
  | { type: 'UPDATE_NOTE'; payload: { id: string; updates: Partial<Note> } }
  | { type: 'DELETE_NOTE'; payload: string };

// Initial state
const initialState: AppState = {
  isLoading: true,
  settings: null,
  shifts: [],
  activeShift: null,
  notes: [],
  weatherData: null,
  currentButtonState: 'go_work',
  todayStatus: null,
  weeklyStatus: {},
  timeDisplayInfo: null,
};

// Reducer
function appReducer(state: AppState, action: AppAction): AppState {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };

    case 'SET_SETTINGS':
      return { ...state, settings: action.payload };

    case 'SET_SHIFTS':
      return { ...state, shifts: action.payload };

    case 'SET_ACTIVE_SHIFT':
      return { ...state, activeShift: action.payload };

    case 'SET_NOTES':
      return { ...state, notes: action.payload };

    case 'SET_WEATHER_DATA':
      return { ...state, weatherData: action.payload };

    case 'SET_BUTTON_STATE':
      return { ...state, currentButtonState: action.payload };

    case 'SET_TODAY_STATUS':
      return { ...state, todayStatus: action.payload };

    case 'SET_WEEKLY_STATUS':
      return { ...state, weeklyStatus: action.payload };

    case 'SET_TIME_DISPLAY_INFO':
      return { ...state, timeDisplayInfo: action.payload };

    case 'UPDATE_SETTINGS':
      return {
        ...state,
        settings: state.settings ? { ...state.settings, ...action.payload } : null
      };

    case 'ADD_SHIFT':
      return { ...state, shifts: [...state.shifts, action.payload] };

    case 'UPDATE_SHIFT':
      return {
        ...state,
        shifts: state.shifts.map(shift =>
          shift.id === action.payload.id
            ? { ...shift, ...action.payload.updates }
            : shift
        ),
        activeShift: state.activeShift?.id === action.payload.id
          ? { ...state.activeShift, ...action.payload.updates }
          : state.activeShift,
      };

    case 'DELETE_SHIFT':
      return {
        ...state,
        shifts: state.shifts.filter(shift => shift.id !== action.payload),
        activeShift: state.activeShift?.id === action.payload ? null : state.activeShift,
      };

    case 'ADD_NOTE':
      return { ...state, notes: [...state.notes, action.payload] };

    case 'UPDATE_NOTE':
      return {
        ...state,
        notes: state.notes.map(note =>
          note.id === action.payload.id
            ? { ...note, ...action.payload.updates }
            : note
        ),
      };

    case 'DELETE_NOTE':
      return {
        ...state,
        notes: state.notes.filter(note => note.id !== action.payload),
      };

    default:
      return state;
  }
}

// Context
interface AppContextType {
  state: AppState;
  dispatch: React.Dispatch<AppAction>;
  actions: {
    loadInitialData: () => Promise<void>;
    updateSettings: (updates: Partial<UserSettings>) => Promise<void>;
    setActiveShift: (shiftId: string | null) => Promise<void>;
    addShift: (shift: Shift, applyImmediately?: boolean) => Promise<void>;
    updateShift: (shiftId: string, updates: Partial<Shift>) => Promise<void>;
    deleteShift: (shiftId: string) => Promise<void>;
    addNote: (note: Note) => Promise<void>;
    updateNote: (noteId: string, updates: Partial<Note>) => Promise<void>;
    deleteNote: (noteId: string) => Promise<void>;
    handleButtonPress: () => Promise<void>;
    handleRapidPressConfirmed: (checkInTime: string, checkOutTime: string) => Promise<void>;
    resetDailyStatus: () => Promise<void>;
    refreshWeatherData: () => Promise<void>;
    refreshButtonState: () => Promise<void>;
    refreshWeeklyStatus: () => Promise<void>;
    refreshTimeDisplayInfo: () => Promise<void>;
    forceRefreshAllStatus: () => Promise<void>;
  };
}

const AppContext = createContext<AppContextType | undefined>(undefined);

// Provider component
interface AppProviderProps {
  children: ReactNode;
}

export function AppProvider({ children }: AppProviderProps) {
  const [state, dispatch] = useReducer(appReducer, initialState);

  // Load initial data
  const loadInitialData = async () => {
    try {
      dispatch({ type: 'SET_LOADING', payload: true });

      // Initialize notification service and alarm service
      await notificationService.initialize();
      await alarmService.initialize();

      // Load all data
      const [settings, shifts, activeShiftId] = await Promise.all([
        storageService.getUserSettings(),
        storageService.getShiftList(),
        storageService.getActiveShiftId(),
      ]);

      // Load notes and add sample data if needed
      let notes = await storageService.getNotes();
      if (notes.length === 0) {
        // Import and add sample data v·ªõi ng√¥n ng·ªØ t·ª´ settings
        const { addSampleNotesToStorage } = await import('../services/sampleData');
        notes = await addSampleNotesToStorage(settings.language);
      }

      dispatch({ type: 'SET_SETTINGS', payload: settings });
      dispatch({ type: 'SET_SHIFTS', payload: shifts });
      dispatch({ type: 'SET_NOTES', payload: notes });

      // Set active shift
      const activeShift = activeShiftId ? shifts.find(s => s.id === activeShiftId) || null : null;
      dispatch({ type: 'SET_ACTIVE_SHIFT', payload: activeShift });

      // Load today's status and button state
      const today = format(new Date(), 'yyyy-MM-dd');
      const todayStatus = await storageService.getDailyWorkStatusForDate(today);
      const buttonState = await workManager.getCurrentButtonState(today);

      dispatch({ type: 'SET_TODAY_STATUS', payload: todayStatus });
      dispatch({ type: 'SET_BUTTON_STATE', payload: buttonState });

      // Load weekly status
      await refreshWeeklyStatus();

      // Load time display info
      await refreshTimeDisplayInfo();

      // Load weather data
      if (settings.weatherWarningEnabled) {
        const weatherData = await weatherService.getWeatherData();
        dispatch({ type: 'SET_WEATHER_DATA', payload: weatherData });
      }

      // ‚úÖ D·ªçn d·∫πp to√†n b·ªô th√¥ng b√°o c≈© khi kh·ªüi ƒë·ªông app ƒë·ªÉ tr√°nh tr√πng l·∫∑p
      console.log('üßπ AppContext: B·∫Øt ƒë·∫ßu d·ªçn d·∫πp th√¥ng b√°o c≈© khi kh·ªüi ƒë·ªông app...');

      // H·ªßy t·∫•t c·∫£ shift reminders c≈©
      await notificationService.cancelAllShiftReminders();
      console.log('üßπ AppContext: ƒê√£ h·ªßy t·∫•t c·∫£ shift reminders c≈©');

      // H·ªßy t·∫•t c·∫£ weekly reminders c≈©
      await notificationService.cancelWeeklyReminders();
      console.log('üßπ AppContext: ƒê√£ h·ªßy t·∫•t c·∫£ weekly reminders c≈©');

      // Check for shift rotation and schedule reminders
      await workManager.checkAndRotateShifts();

      // Ch·ªâ l·∫≠p l·ªãch weekly reminder n·∫øu c√≥ active shift
      // Tr√°nh hi·ªÉn th·ªã th√¥ng b√°o fallback ngay khi kh·ªüi ƒë·ªông app
      if (activeShiftId) {
        await workManager.scheduleWeeklyReminder();
      }

      console.log('‚úÖ AppContext: Ho√†n th√†nh d·ªçn d·∫πp v√† l·∫≠p l·ªãch l·∫°i th√¥ng b√°o');

      // ‚úÖ Kh·ªüi t·∫°o ng√†y ngh·ªâ th√¥ng th∆∞·ªùng (t·ª± ƒë·ªông ƒë·∫∑t Ch·ªß Nh·∫≠t l√† ng√†y ngh·ªâ)
      console.log('üîÑ AppContext: Kh·ªüi t·∫°o ng√†y ngh·ªâ th√¥ng th∆∞·ªùng...');
      await dayOffService.initializeDayOffs();
      console.log('‚úÖ AppContext: Ho√†n th√†nh kh·ªüi t·∫°o ng√†y ngh·ªâ th√¥ng th∆∞·ªùng');

    } catch (error) {
      console.error('Error loading initial data:', error);
    } finally {
      dispatch({ type: 'SET_LOADING', payload: false });
    }
  };

  // Update settings
  const updateSettings = async (updates: Partial<UserSettings>) => {
    try {
      const newSettings = await storageService.updateUserSettings(updates);
      dispatch({ type: 'SET_SETTINGS', payload: newSettings });

      // If weather settings changed, refresh weather data
      if ('weatherWarningEnabled' in updates || 'weatherLocation' in updates) {
        await refreshWeatherData();
      }
    } catch (error) {
      console.error('Error updating settings:', error);
      throw error;
    }
  };

  // Set active shift
  const setActiveShift = async (shiftId: string | null) => {
    try {
      await storageService.setActiveShiftId(shiftId);
      const activeShift = shiftId ? state.shifts.find(s => s.id === shiftId) || null : null;
      dispatch({ type: 'SET_ACTIVE_SHIFT', payload: activeShift });

      // Handle rotation config if in rotate mode
      if (state.settings?.changeShiftReminderMode === 'rotate' && state.settings.rotationConfig && shiftId) {
        const rotationShifts = state.settings.rotationConfig.rotationShifts;
        const newIndex = rotationShifts.findIndex(id => id === shiftId);

        if (newIndex >= 0) {
          // Update rotation index and reset last applied date
          await storageService.updateUserSettings({
            rotationConfig: {
              ...state.settings.rotationConfig,
              currentRotationIndex: newIndex,
              rotationLastAppliedDate: new Date().toISOString(),
            }
          });
        } else {
          // Shift not in rotation list - show warning
          console.warn('Selected shift is not in rotation list');
        }
      }

      // ‚úÖ D·ªçn d·∫πp v√† l·∫≠p l·ªãch l·∫°i th√¥ng b√°o cho ca m·ªõi
      console.log('üîÑ AppContext: B·∫Øt ƒë·∫ßu c·∫≠p nh·∫≠t th√¥ng b√°o cho ca m·ªõi...');

      // H·ªßy t·∫•t c·∫£ th√¥ng b√°o c≈© tr∆∞·ªõc
      await notificationService.cancelAllShiftReminders();
      await alarmService.cancelShiftReminders();
      await notificationService.cancelWeeklyReminders();
      console.log('üßπ AppContext: ƒê√£ h·ªßy t·∫•t c·∫£ th√¥ng b√°o c≈©');

      // L·∫≠p l·ªãch th√¥ng b√°o m·ªõi n·∫øu c√≥ active shift
      if (activeShift) {
        await notificationService.scheduleShiftReminders(activeShift);
        await alarmService.scheduleShiftReminder(activeShift);
        await workManager.scheduleWeeklyReminder();
        console.log(`‚úÖ AppContext: ƒê√£ l·∫≠p l·ªãch th√¥ng b√°o cho ca ${activeShift.name}`);
      } else {
        console.log('‚ÑπÔ∏è AppContext: Kh√¥ng c√≥ ca ho·∫°t ƒë·ªông, b·ªè qua l·∫≠p l·ªãch th√¥ng b√°o');
      }

      // Refresh button state and time display info
      await refreshButtonState();
      await refreshTimeDisplayInfo();
    } catch (error) {
      console.error('Error setting active shift:', error);
      throw error;
    }
  };

  // Add shift
  const addShift = async (shift: Shift, applyImmediately: boolean = false) => {
    try {
      await storageService.addShift(shift);
      dispatch({ type: 'ADD_SHIFT', payload: shift });

      if (applyImmediately) {
        await setActiveShift(shift.id);
      }
    } catch (error) {
      console.error('Error adding shift:', error);
      throw error;
    }
  };

  // Update shift
  const updateShift = async (shiftId: string, updates: Partial<Shift>) => {
    try {
      await storageService.updateShift(shiftId, updates);
      dispatch({ type: 'UPDATE_SHIFT', payload: { id: shiftId, updates } });

      // If this is the active shift, reschedule reminders
      if (state.activeShift?.id === shiftId) {
        const updatedShift = { ...state.activeShift, ...updates };
        await notificationService.scheduleShiftReminders(updatedShift);
      }
    } catch (error) {
      console.error('Error updating shift:', error);
      throw error;
    }
  };

  // Delete shift
  const deleteShift = async (shiftId: string) => {
    try {
      await storageService.deleteShift(shiftId);
      dispatch({ type: 'DELETE_SHIFT', payload: shiftId });

      // If this was the active shift, clear it
      if (state.activeShift?.id === shiftId) {
        await storageService.setActiveShiftId(null);
        await notificationService.cancelShiftReminders();
      }
    } catch (error) {
      console.error('Error deleting shift:', error);
      throw error;
    }
  };

  // Add note
  const addNote = async (note: Note) => {
    try {
      await storageService.addNote(note);
      dispatch({ type: 'ADD_NOTE', payload: note });

      // Schedule reminder if set (both notifications and alarms)
      // H·ªó tr·ª£ c·∫£ specific datetime v√† shift-based reminders
      if (note.reminderDateTime || (note.associatedShiftIds && note.associatedShiftIds.length > 0)) {
        await notificationService.scheduleNoteReminder(note);
        await alarmService.scheduleNoteReminder(note);
      }
    } catch (error) {
      console.error('Error adding note:', error);
      throw error;
    }
  };

  // Update note
  const updateNote = async (noteId: string, updates: Partial<Note>) => {
    try {
      await storageService.updateNote(noteId, updates);
      dispatch({ type: 'UPDATE_NOTE', payload: { id: noteId, updates } });

      // Update reminder (both notifications and alarms)
      await notificationService.cancelNoteReminder(noteId);
      await alarmService.cancelNoteReminder(noteId);

      const updatedNote = state.notes.find(n => n.id === noteId);
      if (updatedNote) {
        const newNote = { ...updatedNote, ...updates } as Note;
        // H·ªó tr·ª£ c·∫£ specific datetime v√† shift-based reminders
        if (newNote.reminderDateTime || (newNote.associatedShiftIds && newNote.associatedShiftIds.length > 0)) {
          await notificationService.scheduleNoteReminder(newNote);
          await alarmService.scheduleNoteReminder(newNote);
        }
      }
    } catch (error) {
      console.error('Error updating note:', error);
      throw error;
    }
  };

  // Delete note
  const deleteNote = async (noteId: string) => {
    try {
      await storageService.deleteNote(noteId);
      dispatch({ type: 'DELETE_NOTE', payload: noteId });

      // Cancel reminder (both notifications and alarms)
      await notificationService.cancelNoteReminder(noteId);
      await alarmService.cancelNoteReminder(noteId);
    } catch (error) {
      console.error('Error deleting note:', error);
      throw error;
    }
  };

  // Handle button press - Improved with better error handling and state management
  const handleButtonPress = async () => {
    try {
      // Validate prerequisites
      if (!state.activeShift) {
        throw new Error('Kh√¥ng c√≥ ca l√†m vi·ªác ƒëang ho·∫°t ƒë·ªông');
      }

      await workManager.handleButtonPress(state.currentButtonState);

      // Batch state updates to reduce re-renders
      const today = format(new Date(), 'yyyy-MM-dd');
      const [newButtonState, todayStatus, weeklyStatus] = await Promise.all([
        workManager.getCurrentButtonState(today),
        storageService.getDailyWorkStatusForDate(today),
        (async () => {
          const weeklyStatus: Record<string, DailyWorkStatus> = {};
          const todayDate = new Date();

          for (let i = -6; i <= 0; i++) {
            const date = new Date(todayDate);
            date.setDate(todayDate.getDate() + i);
            const dateString = format(date, 'yyyy-MM-dd');

            const status = await storageService.getDailyWorkStatusForDate(dateString);
            if (status) {
              weeklyStatus[dateString] = status;
            }
          }
          return weeklyStatus;
        })()
      ]);

      // Update all states at once
      dispatch({ type: 'SET_BUTTON_STATE', payload: newButtonState });
      dispatch({ type: 'SET_TODAY_STATUS', payload: todayStatus });
      dispatch({ type: 'SET_WEEKLY_STATUS', payload: weeklyStatus });

    } catch (error) {
      // Ch·ªâ log error n·∫øu kh√¥ng ph·∫£i RapidPressDetectedException
      if ((error as any)?.name !== 'RapidPressDetectedException') {
        console.error('Error handling button press:', error);
      }
      // Lu√¥n throw ƒë·ªÉ UI component x·ª≠ l√Ω
      throw error;
    }
  };

  // Handle rapid press confirmation - t√≠nh ƒë·ªß c√¥ng theo l·ªãch tr√¨nh
  const handleRapidPressConfirmed = async (checkInTime: string, checkOutTime: string) => {
    try {
      console.log('üöÄ AppContext: handleRapidPressConfirmed started', { checkInTime, checkOutTime });

      const today = format(new Date(), 'yyyy-MM-dd');
      const logs = await storageService.getAttendanceLogsForDate(today);

      console.log('üöÄ AppContext: Retrieved logs for today:', logs.length);

      if (!state.activeShift) {
        console.error('‚ùå AppContext: No active shift found');
        throw new Error('Kh√¥ng c√≥ ca l√†m vi·ªác ƒëang ho·∫°t ƒë·ªông');
      }

      console.log('üöÄ AppContext: Active shift found:', state.activeShift.name);

      // Th√™m check_out log tr∆∞·ªõc khi t√≠nh to√°n status
      console.log('üöÄ AppContext: Adding check_out log for rapid press confirmation');
      const updatedLogs = [...logs];
      const checkOutLog = { type: 'check_out' as const, time: checkOutTime };
      updatedLogs.push(checkOutLog);

      // ‚úÖ T·ª± ƒë·ªông th√™m complete log ngay sau check_out ƒë·ªÉ ho√†n t·∫•t quy tr√¨nh
      console.log('üöÄ AppContext: Auto-adding complete log for rapid press confirmation');
      const completeLog = { type: 'complete' as const, time: checkOutTime };
      updatedLogs.push(completeLog);

      await storageService.setAttendanceLogsForDate(today, updatedLogs);

      // T√≠nh to√°n work status v·ªõi x√°c nh·∫≠n "b·∫•m nhanh"
      console.log('üöÄ AppContext: Calling calculateDailyWorkStatusWithRapidPressConfirmed');
      const status = await workManager.calculateDailyWorkStatusWithRapidPressConfirmed(
        today,
        updatedLogs,
        state.activeShift,
        checkInTime,
        checkOutTime
      );

      console.log('üöÄ AppContext: Calculated status:', status);

      // L∆∞u k·∫øt qu·∫£
      console.log('üöÄ AppContext: Saving status to storage');
      await storageService.setDailyWorkStatusNewForDate(today, status);

      // ‚úÖ FIX: Refresh state KH√îNG g·ªçi refreshButtonState() ƒë·ªÉ tr√°nh trigger l·∫°i rapid press detection
      // Thay v√†o ƒë√≥, set tr·ª±c ti·∫øp button state th√†nh 'completed_day'
      console.log('üöÄ AppContext: Setting button state to completed_day after rapid press confirmation');
      dispatch({ type: 'SET_BUTTON_STATE', payload: 'completed_day' });

      // Ch·ªâ refresh weekly status v√† today status
      await refreshWeeklyStatus();
      const todayStatus = await storageService.getDailyWorkStatusForDate(today);
      dispatch({ type: 'SET_TODAY_STATUS', payload: todayStatus });

      console.log('‚úÖ AppContext: ƒê√£ x·ª≠ l√Ω x√°c nh·∫≠n b·∫•m nhanh th√†nh c√¥ng');
    } catch (error) {
      console.error('‚ùå AppContext: Error handling rapid press confirmation:', error);
      throw error;
    }
  };

  // Reset daily status
  const resetDailyStatus = async () => {
    try {
      const today = format(new Date(), 'yyyy-MM-dd');
      console.log('üîÑ AppContext: Starting reset daily status');

      await workManager.resetDailyStatus(today);

      console.log('üîÑ AppContext: Reset completed, refreshing states');

      // Force refresh button state immediately
      const newButtonState = await workManager.getCurrentButtonState(today);
      dispatch({ type: 'SET_BUTTON_STATE', payload: newButtonState });

      // Clear today status
      dispatch({ type: 'SET_TODAY_STATUS', payload: null });

      // Refresh other states
      await refreshWeeklyStatus();

      console.log(`‚úÖ AppContext: Reset daily status completed, new button state: ${newButtonState}`);
    } catch (error) {
      console.error('Error resetting daily status:', error);
      throw error;
    }
  };

  // Refresh weather data
  const refreshWeatherData = async () => {
    try {
      if (state.settings?.weatherWarningEnabled) {
        const weatherData = await weatherService.getWeatherData(true);
        dispatch({ type: 'SET_WEATHER_DATA', payload: weatherData });
      }
    } catch (error) {
      console.error('Error refreshing weather data:', error);
    }
  };

  // Refresh button state
  const refreshButtonState = async () => {
    try {
      const today = format(new Date(), 'yyyy-MM-dd');
      const buttonState = await workManager.getCurrentButtonState(today);
      dispatch({ type: 'SET_BUTTON_STATE', payload: buttonState });
    } catch (error) {
      console.error('Error refreshing button state:', error);
    }
  };

  // Refresh weekly status
  const refreshWeeklyStatus = async () => {
    try {
      const weeklyStatus: Record<string, DailyWorkStatus> = {};
      const today = new Date();

      // Get current week (Monday to Sunday) - same logic as WeeklyStatusGrid
      const startOfCurrentWeek = startOfWeek(today, { weekStartsOn: 1 }); // Monday

      // Get status for all 7 days of current week
      for (let i = 0; i < 7; i++) {
        const date = addDays(startOfCurrentWeek, i);
        const dateString = format(date, 'yyyy-MM-dd');

        const status = await storageService.getDailyWorkStatusForDate(dateString);
        if (status) {
          weeklyStatus[dateString] = status;
        }
      }

      dispatch({ type: 'SET_WEEKLY_STATUS', payload: weeklyStatus });
    } catch (error) {
      console.error('Error refreshing weekly status:', error);
    }
  };

  // Refresh time display info
  const refreshTimeDisplayInfo = async () => {
    try {
      const timeDisplayInfo = await workManager.getTimeDisplayInfo();
      dispatch({ type: 'SET_TIME_DISPLAY_INFO', payload: timeDisplayInfo });
    } catch (error) {
      console.error('Error refreshing time display info:', error);
    }
  };

  // ‚úÖ Force refresh t·∫•t c·∫£ tr·∫°ng th√°i - d√πng cho debug
  const forceRefreshAllStatus = async () => {
    try {
      console.log('üîÑ AppContext: Force refreshing all status...');

      const today = format(new Date(), 'yyyy-MM-dd');

      // Force t√≠nh l·∫°i tr·∫°ng th√°i t·ª´ logs
      await workManager.recalculateFromAttendanceLogs(today);

      // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o storage ƒë∆∞·ª£c c·∫≠p nh·∫≠t
      await new Promise(resolve => setTimeout(resolve, 300));

      // Refresh t·∫•t c·∫£ state
      await Promise.all([
        refreshButtonState(),
        refreshWeeklyStatus(),
        refreshTimeDisplayInfo()
      ]);

      console.log('‚úÖ AppContext: Force refresh completed');

    } catch (error) {
      console.error('‚ùå AppContext: Error force refreshing status:', error);
    }
  };

  // Initialize app on mount
  useEffect(() => {
    loadInitialData();
  }, []);

  // Refresh time display info every minute - Optimized with debouncing
  useEffect(() => {
    let interval: NodeJS.Timeout;

    // Only start interval if we have active shift and not loading
    if (!state.isLoading && state.activeShift) {
      interval = setInterval(async () => {
        try {
          const today = format(new Date(), 'yyyy-MM-dd');

          // Ki·ªÉm tra v√† th·ª±c hi·ªán auto-reset n·∫øu c·∫ßn
          const wasReset = await workManager.performAutoResetIfNeeded(today);

          // Batch updates to reduce re-renders
          await Promise.all([
            refreshTimeDisplayInfo(),
            refreshButtonState()
          ]);

          // N·∫øu c√≥ auto-reset, refresh th√™m weekly status
          if (wasReset) {
            await refreshWeeklyStatus();
            dispatch({ type: 'SET_TODAY_STATUS', payload: null });
          }
        } catch (error) {
          console.error('Error in periodic refresh:', error);
        }
      }, 60000); // Every minute
    }

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [state.isLoading, state.activeShift?.id]); // Use activeShift.id instead of whole object



  const contextValue: AppContextType = {
    state,
    dispatch,
    actions: {
      loadInitialData,
      updateSettings,
      setActiveShift,
      addShift,
      updateShift,
      deleteShift,
      addNote,
      updateNote,
      deleteNote,
      handleButtonPress,
      handleRapidPressConfirmed,
      resetDailyStatus,
      refreshWeatherData,
      refreshButtonState,
      refreshWeeklyStatus,
      refreshTimeDisplayInfo,
      forceRefreshAllStatus,
    },
  };

  return (
    <AppContext.Provider value={contextValue}>
      {children}
    </AppContext.Provider>
  );
}

// Hook to use the context
export function useApp() {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
}
